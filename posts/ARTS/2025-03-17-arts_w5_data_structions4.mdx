---
layout: post
title: "[A]RTS 数据结构的基石4"
date: 2025-03-17
categories: []
tags: [ARTS]
---

## 前言

🌲树有很多形态这周我会深入这些形态，这篇是[上篇](/a-rts_w4_data_structions3)的补充。

## 二叉搜索树 {#binary_tree}
二叉搜索树（binary search tree）也就是**二叉查找树**。这个树类型是在二叉树性质的基础上
增加了3个新性质。
1. 若任意结点的左子树不空，则**左子树的所有结点**的值均**小于**它的**根结点**的值；
2. 若任意结点的右子树不空，则**右子树的所有结点**的值均**大于**它的**根结点**的值；
3. 任意节点的左右子树都分别是二叉查找树。

这三个性质为了让数据的查找和插入时间为$\mathcal{O}(log_n)$。与之前我们聊过的[二分搜索](/a-rts_w3_data_structions2#binary_search)类似
二叉搜索树是把二分搜索的逻辑显式的嵌入了数据结构中，如此这样大幅下降了查找和插入的时间。值的一提的是一些抽象数据结构也是由这个基本数据结构
所构成的比如集合、multiset、dictionary。

<div style="background-color:#d0e7f9; color:#4d4d4d; padding:10px; border-radius:5px;">
这里可以给我一些想法，我对数据结构的理解有了不同的角度，数据结构如果从性质入手来实现也许不是很直观，但把数据结构再解构，从数据解构的查找，插入，删除，修改这几个方面
来想很多数据结构就很容易处理了。比如如果我需要实现dictionary，也许一个hash
table就可以处理，但是把字典这个数据解构分解，其实只是需要找到一种方案插入和查找字典中的元素就可以了
</div>
二叉查找树性质非常完美，但如果你需要对这个数据结构进行修改(比如插入或者删除某些数据)，那就有可能会让这个特征消失从而增加各项操作的时间，它的最坏情况也很好理解，通过一系列运算让整个
数据结构变成一个链表所以最差的情况是$\mathcal{O}(n)$。为了对抗这个衰变之后又出现了[AVL树](#avl_tree)、[红黑树](#red_black_tree)、 [跳表](#jump_table)、 [B树](#b_tree)一系列的数据解构来解决.

## 树旋转 {#Tree_rotation}
在谈论各种不同的树类型的时候我们需要了解一种对二叉树的操作，树旋转。<br>
**树旋转**操作**不会**影响这棵树的**中序遍历**结点顺序，但会影响这棵树的**结构**。<br>
**树的结构**直接影响到对这棵树的操作的时间复杂度。树旋转的目的是在逻辑顺序不变的情况下保持高效率的树结构

![tree rotation](/assets/20250317_data_structure_04_btr.svg)

左边的二叉树的中序遍历是(a、黄、b、绿、y) 右边的二叉树的中序遍历也是(a、黄、b、绿、y)，但是两棵树的结构不一样了。

由于树旋转有很多定义，这篇文章采用的是**旋转方向**是**节点的移动方向**。按照上图所演示，以黄色节点为根节点，从左往右的旋转是左旋。


我们可以通过使用树旋转让目标树在中序遍历相同的情况下，20250317_data_structure_04_tree_rotation.svg仍然保持二叉树的结构而避免劣化成**链表**。

## 执行树旋转
![tree_rotation_detail](/assets/20250317_data_structure_04_tree_rotation.svg)

**左旋转（Left Rotation）**：将一个节点的右子节点“上提”作为新的根，原根节点变成新根的左子节点。<br>
**右旋转（Right Rotation）**：将一个节点的左子节点“上提”作为新的根，原根节点变成新根的右子节点。<br>

右旋转的核心：
* 选择一个节点（X）
* 将X的左子节点（Y）上提为新的根。
* X变成Y的右子节点。
* 如果Y原来有右子结点，这个右子节点会变成X的左子节点。

我们沿用上篇文章的树的序列化表示假设存在一种树`T=Q(P(A,B), C())`我们对它做右旋转。
```c
//目标树
      Q
     / \
    P   C
   / \
  A   B
```

* 右旋过程

* Q的左子结点是P，上提P为新的根
* Q变成P的右子结点。
* 原来的P有右子结点B，所以B需要变成Q的左子结点。

```c
//右旋后的树
    P
   / \
  A   Q
     / \
    B   C
```

左旋是一种镜像操作，这里给出C代码代替。
```c
// left rotation
void LL(node_t *node, node_t *pnode)
{
    assert(node);
    node_t *node_r = node->right;
    if (pnode->left == node) {
        pnode->left = node_r;
    } else {
        pnode->right = node_r;
    }
    node->right = NULL;

    node_t *node_r_l = node_r->left;
    if (!node_r->left) {
        node_r->left = node;
    } else if (node_r->left && node_r->right) {
        node_t *node_r_r = node_r->right;
        node_r->left = node;
        node_r->right = node_r_l;
        node_r_l->right = node_r_r;
    } else {  // has left no right
        node_r->left = node;
        node_r->right = node_r_l;
    }
}
```
树旋转是保持二叉树平衡的关键。

## AVL树 {#avl_tree}
**AVL树**（Adelson-Velskii and Landis tree）是一种自平衡二叉树，我们在[上一节](#binary_tree)提到过二叉树虽然各项操作的时间复杂度都很优秀($\mathcal{O}(log_n)$)但是由于对二叉搜索树的插入和删除会改变树
的结构，这样树的特征就会消失。如果存在一种可以始终保持二叉树结构的数据结构这样就可以通过机制对抗二叉搜索树的结构散失提供一种解决方案。

<div markdown="1" style="background-color:#d0e7f9; color:#4d4d4d; padding:10px; border-radius:5px;">
可以用**熵增**的概念来理解AVL树做的事情。因为对二叉树的插入和删除操作，对于二叉树来说相当于熵增，而AVL树提供一系列方案
来试图让这棵树变得有规律，这就是**熵减**。
</div>

| 时间复杂度 | 平均                | 最差                |
|------------|---------------------|---------------------|
| 插入       | $\mathcal{O}(logn)$ | $\mathcal{O}(logn)$ |
| 删除       | $\mathcal{O}(logn)$ | $\mathcal{O}(logn)$ |
| 搜索       | $\mathcal{O}(logn)$ | $\mathcal{O}(logn)$ |

## AVL树计算熵---平衡因子
为了保持一种二叉树结构，AVL树利用了一个叫做**平衡因子**的概念来描述目标的树是否需要“整理” <br>

* 节点的**平衡因子**是它的***左子树*的高度**减去它**右子树高度**。<br>
* 平衡因子是**1、0或-1**的节点被认为是**平衡**的。<br>
* 当带有**-2或2**的平衡因子节点则是**不平衡**的，这时候就需要重新平衡这棵树。

## AVL旋转
这里的AVL旋转就是树旋转，树旋转我们已经介绍过了。avl旋转就是在发现根节点的平衡因子大于2或者小于-2的时候
进行旋转。这里分为单次旋转（single rotation），和两次旋转（double rotation）。

![tree_rotation](/assets/20250317_data_structure_04_tree_rebalancing.jpg)

ASCII 演示如下
每个节点右侧是他们的平衡因子。
## 右旋
```c
        2 (+2)
       /
  1 (+1)
 /
0 (0)
```
## 左旋
```c
  0 (-2)
   \
    1 (-1)
     \
      2 (0)

```
## 右左旋转（Right-Left Rotation）
```c
  1 (-2)
   \
    3 (+1)
   /
  2 (0)
```
先对节点3右旋
```c
  1 (-2)
   \
    2 (-1)
     \
      3 (0)

```
再对节点1左旋
```c

      2 (0)
     /   \
  1 (0)  3 (0)
```

## 左右旋转（Left-right rotation）
```c
      3 (+2)
     /
    1 (-1)
     \
      2 (0)
```

先对节点1左旋
```c
      3 (+2)
     /
    2 (+1)
   /
  1 (0)

```

再对节点3右旋
```c
    2 (0)
   /   \
  1 (0) 3 (0)
```


这四种旋转模式针对四种状态。
1. 对目标树的左子树的左子节点添加节点 (LL)
2. 对目标树的左子树的右子节点添加节点 (LR)
3. 对目标树的右子树的左子节点添加节点 (RL)
4. 对目标树的右子树的右子节点添加节点 (RR)

AVL树的各项操作的时间复杂度都很优秀，由于在插入和删除时需要保持平衡，所以在频繁插入和删除场景时候成本很高。
在查多改少的情况更适合使用AVL树，如果需要频繁插入和删除就可能需要选择**红黑树**了。

## B tree {#b_tree}

之前我们讨论的树结构都是假设整棵树都在内存里，由于内存是有限的所以总会出现一种没法全部加载到内存里的树结构，
这样即使我们使用了二叉树结构也会因为内存总量的原因导致需要进行更多次的页面的写入写出，大概需要$logN$次I/O访问 N是数据总量。
为了在一次访问I/O可以获得更多的数据，压缩树的高度变成一种方法。B树就是Rudolf Bayer针对如此困难发明出来的。

| 时间复杂度 | 平均                | 最差                |
|------------|---------------------|---------------------|
| 插入       | $\mathcal{O}(logn)$ | $\mathcal{O}(logn)$ |
| 删除       | $\mathcal{O}(logn)$ | $\mathcal{O}(logn)$ |
| 搜索       | $\mathcal{O}(logn)$ | $\mathcal{O}(logn)$ |

## B树的阶
**B树**在实际使用的时候会带上它的阶，一般称之为**m阶的B树**。
m阶B树是指满足如下属性的树

1. 每个节点**最多**有m个子节点
2. **除了根节点及叶子节点**外，每个节点**至少**有 $ \lceil \frac{m}{2} \rceil $ 个子节点
3. 根节点**至少**有**2个**子节点（除非它是一个叶子）
4. 所有的叶子都出现在**同一级别**，并且不携带任何信息
5. 具有k个子节点的**非叶节点**包含k-1个键。

> ![b-tree in order 4](/assets/20250317_data_structure_04_Btree.jpg)
> 4阶B树

## B树的插入
B树插入的主要分4种情况

1. 直接插入
2. 插入导致叶子节点溢出
3. 插入导致多个向上分裂
4. 分裂根节点


假设需要插入`42`到如上4阶B树
1. 查找根节点发现`21<42<48`所以查找第二层第2个节点{25,31,41}
2. 继续比较 `41<42`，应该插入第三层{41,43,46}，由于这个节点已经超过了3个也就是m-1,这时候需要分裂这个节点{41,43,46,42}42会被提升节点会分裂成两个{41}{43,46}
3. `42` 被提升到 {25,31,41}，这时候这个节点也满了，继续找中间键上移，`31`，节点分裂成{25}、{41,42}
4. `31` 被提升到 {21,48,72}，这时候根节点也满了，继续找中间键`31`，这个节点继续分裂成，{21}、{48,72}
5. `31` 这时候 `31` 就变成了新的根节点。

有趣的是B树增长方向是根的方向

## B树的删除
B树的删除主要分为3种情况
1. 删除的键在叶子节点
2. 删除的键在内部节点
3. 删除后节点键数不足（小于t-1），需要借位（旋转）或者合并来维持平衡。

#### 情况1：删除叶子节点
规则：
* 直接删除
```c
       [30]
      /    \
  [10]    [40 50]
  // 删除10,因为10在叶子节点，可以直接删除
       [30]
         \
       [40 50]
```

#### 情况2：删除内部节点
规则：
* 用前驱（左子树的最大值）或后继（右子树最小值）替换被删除的键
* 然后递归的删除前驱或者后继键（最后会落入叶子节点，回到情况1）

```c
       [40]
      /    \
  [20]    [50 60]
// 删除40, 因为40是内部节点
// 左子树的最大值 20 或者 右子树的最小值50可以替换40
// 50 替换 40, 删除50
       [50]
      /    \
  [20]    [60]
```
#### 情况3：删除导致节点键数不足
如果删除某个键导致节点键数小于 t-1 ，则需要借位（rotation）或合并来恢复平衡。
* 借位 Rotation
* 合并 Merge

假设需要删除第二层的`59`到如上4阶B树
1. 这时候是情况2需要在前驱{48,49,50}最大值或者后继{59,68}最小值，我们选`50`替换`59`


## 后
这是上周的内容，上周有一些事情没有发表。这次提供了一些常见的二叉查找树的数据结构，之后会提到红黑树和跳表这两个使用最广泛的树。

Sat Mar 29 11:19:10 AM CST 2025
