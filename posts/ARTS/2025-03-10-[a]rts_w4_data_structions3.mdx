---
layout: post
title: "[A]RTS æ•°æ®ç»“æ„çš„åŸºçŸ³3"
date: 2025-03-08
categories: []
tags: [ARTS]
---
## æ ‘ä¸é€’å½’

æˆ‘ä»¬åœ¨[åŸºçŸ³1](/a-rts_w2_data_structions)å’Œ[åŸºçŸ³2](a-rts_w3_data_structions2)ä¸­æ¢è®¨äº†çº¿æ€§ç»“æ„é“¾è¡¨å’Œæ•°ç»„ï¼Œè¿™å‘¨å¼€å§‹è®¨è®ºä¸€ç§éçº¿æ€§ç»“æ„**æ ‘**ã€‚

æ ‘ç»“æ„æ˜¯ç»“ç‚¹ä¹‹é—´çš„â€œåˆ†æ”¯â€å…³ç³»ï¼Œå°±åƒæ ‘ğŸŒ²ä»èŠ½ç‚¹å‘å‡ºæ–°çš„æå¹²ä¸€æ ·ã€‚

æ ‘çš„**å½¢å¼åŒ–å®šä¹‰**æ˜¯å…·æœ‰**ä¸€ä¸ªæˆ–å¤šä¸ª**ç»“ç‚¹çš„æœ‰é™é›†åˆ$T$ï¼Œä½¿å¾—
* æœ‰ä¸€ä¸ªä½œä¸ºæ ‘æ ¹çš„ç‰¹å®šç»“ç‚¹$root$ã€‚
* å‰©ä¸‹çš„ç»“ç‚¹ï¼Œè¢«åˆ’åˆ†ç»“ç‚¹$m \gt =0$ä¸ªä¸ç›¸äº¤çš„é›†åˆ$T_i...T_m$ï¼Œå¹¶ä¸”è¿™ä¸ªé›†åˆä¸­çš„æ¯ä¸€ä¸ªéƒ½æ˜¯æ ‘ï¼Œå¹¶ä¸”è¿™äº›
ç»“ç‚¹$T_i...T_m$è¢«ç§°ä¸ºæ ¹çš„å­æ ‘ã€‚

ä¸Šè¿°å®šä¹‰å¯ä»¥å¾—åˆ°ä¸€äº›å…³äº**æ ‘çš„æ€§è´¨**ã€‚
1. æ ‘çš„æ¯ä¸€ä¸ªç»“ç‚¹éƒ½æ˜¯åŒ…å«åœ¨æ ‘ä¸­çš„æŸæ£µå­æ ‘çš„æ ¹
2. ä¸€ä¸ªç»“ç‚¹çš„å­æ ‘ä¸ªæ•°ç§°ä¹‹ä¸ºè¿™ä¸ªç»“ç‚¹çš„**åº¦ï¼ˆdegreeï¼‰**
3. **åº¦ä¸ºé›¶**çš„ç»“ç‚¹æ˜¯è¿™ä¸ªæ ‘çš„**å¶å­ç»“ç‚¹ï¼ˆleafï¼‰**æˆ–è€…**ç»ˆç«¯ç»“ç‚¹ï¼ˆterminal nodeï¼‰**
4. **éå¶å­ç»“ç‚¹**çš„è¢«ç§°ä¹‹ä¸º**åˆ†æ”¯ç»“ç‚¹ï¼ˆbranch nodeï¼‰**
5. ä¸€é¢—æ ‘çš„**å±‚**ï¼Œ**rootç»“ç‚¹ä¸ºç¬¬0å±‚**ï¼Œå…¶ä»–ç»“ç‚¹éƒ½æ¯”åŒ…å«å®ƒçš„ç»“ç‚¹çš„rootå­æ ‘å¯¹åº”çš„å±‚å¤§ä¸€

æ ‘çš„è¡¨è¾¾æ–¹å¼æœ‰å¾ˆå¤šï¼Œè¿™ç¯‡æ–‡ç« ä¼šä½¿ç”¨ä¼ ç»Ÿ**æ ¹åœ¨ä¸Šå¶å­åœ¨ä¸‹**çš„æ–¹å¼ç»˜åˆ¶å›¾åƒï¼Œä¹Ÿä¼šæå‡ºä¸€ç§**åµŒå¥—æ‹¬å·**çš„ä»£ç è¡¨ç¤ºæ–¹å¼ã€‚

<pre class="mermaid" style="text-align: center;">
graph TD
    A ---> B
    A ---> C
    B --> E
    B --> D
    C --> F
    C --> G
    C --> H
    G --> I

    class C,D blueNode;
    class E,F greenNode
    classDef blueNode fill:#aaaaff,stroke:#0000ff,stroke-width:2px;
    classDef greenNode fill:#aaccff,stroke:#00ffff,stroke-width:2px;
</pre>

## äºŒå‰æ ‘
**äºŒå‰æ ‘**æ˜¯æˆ‘ä»¬ä¸»è¦å…³æ³¨çš„æ ‘ç»“æ„ã€‚åœ¨äºŒå‰æ ‘ä¸­ï¼Œæ¯ä¸ªç»“ç‚¹æœ€å¤šæœ‰ä¸¤é¢—å­æ ‘ï¼Œåœ¨åªæœ‰ä¸€é¢—å­æ ‘çš„æ—¶å€™éœ€è¦åŒºåˆ†å·¦å³å­æ ‘ã€‚
äºŒå‰æ ‘çš„ç»“ç‚¹å¯ä»¥æ˜¯ä¸€ä¸ª**æœ‰é™é›†åˆ**ï¼Œè¿™ä¸ªé›†åˆå¯ä»¥æ˜¯**ç©ºé›†**ã€‚äºŒå‰æ ‘ç”±ä¸€ä¸ªæ ¹ç»“ç‚¹å’Œä¸¤æ£µä½œä¸ºè¯¥æ ¹ç»“ç‚¹çš„å·¦å³å­æ ‘çš„äºŒå‰æ ‘ï¼ˆè¿™ä¸¤ä¸ªäºŒå‰æ ‘ä¸ç›¸äº¤ï¼‰

äºŒå‰æ ‘å¹¶ä¸æ˜¯æ ‘çš„ç‰¹æ®Šæƒ…å†µï¼Œè€Œæ˜¯ä¸€ç§å®Œå…¨ä¸åŒçš„æ¦‚å¿µã€‚

äºŒå‰æ ‘çš„ä¸€äº›**æ€§è´¨**
1. äºŒå‰æ ‘å¯ä»¥æ˜¯ä¸€ä¸ªç©ºé›†
2. äºŒå‰æ ‘åŒæ ·çš„é›†åˆï¼Œä¹Ÿå¯ä»¥å› ä¸ºå·¦å³å­æ ‘ä½ç½®ä¸åŒè€Œä¸æ˜¯åŒæ ·çš„äºŒå‰æ ‘

å¦‚ä¸‹ä½¿ç”¨ä¸€ç§å­—ç¬¦ä¸²è¡¨è¾¾æ–¹å¼æ¥è¡¨ç¤ºäºŒå‰æ ‘ï¼Œä¹‹åæˆ‘ä¼šåœ¨ä»£ç ä¸­ä½¿ç”¨è¿™æ ·çš„æ–¹å¼åˆ›å»ºå®éªŒæ•°æ®
```c
char *str = "5(4(2,3),7(0,9(8,10)))";
```
## äºŒå‰æ ‘éå†
éå¸¸å¤šçš„ç®—æ³•éƒ½éœ€è¦èµ°éä¸€æ£µæ ‘ï¼Œä¸å¤šä¸å°‘çš„éå†æ ‘çš„æ¯ä¸€ä¸ªç»“ç‚¹æœ‰3ç§æ–¹æ¡ˆï¼Œå‰ã€ä¸­ã€ååºéå†,
éå†æ–¹æ¡ˆè®©æˆ‘ä»¬å¯ä»¥åœ¨è°ˆè®ºä¸€æ£µæ ‘çš„ç»“ç‚¹çš„æ—¶å€™å¯ä»¥é€šè¿‡ä¸Šä¸€ä¸ªå’Œä¸‹ä¸€ä¸ªç»“ç‚¹æ¥è®¨è®ºã€‚

è¿™é‡Œæœ‰ä¸ªå¯ä»¥å¼ºè°ƒçš„åœ°æ–¹äºŒå‰æ ‘çš„xåºéå†çš„xä»£è¡¨çš„æ˜¯**æ ¹ç»“ç‚¹**è¢«éå†çš„é¡ºåºï¼Œå‰åˆ™æ˜¯å…ˆéå†æ ¹ï¼Œä¾æ¬¡æ˜¯ä¸­é—´éå†æ ¹å’Œæœ€åéå†æ ¹ã€‚å·¦å³å­æ ‘çš„éå†ä»æ¥éƒ½æ˜¯å…ˆå·¦åå³ã€‚
## å‰åºéå†ï¼ˆpreorderï¼‰

å…ˆè®¿é—®æ ¹ç»“ç‚¹ï¼Œéå†å·¦å­æ ‘ï¼Œéå†å³å­æ ‘
## ä¸­åºéå†ï¼ˆinorderï¼‰
å…ˆè®¿é—®å·¦å­æ ‘ï¼Œè®¿é—®æ ¹ï¼Œéå†å³å­æ ‘
## ååºéå†ï¼ˆpostorderï¼‰
å…ˆè®¿é—®å·¦å­æ ‘ï¼Œéå†å³è¾¹å­æ ‘ï¼Œè®¿é—®æ ¹

## å±‚åºéå†
å±‚åºéå†æ˜¯é€šè¿‡ä¸€ä¸ªé˜Ÿåˆ—æˆ–è€…æ ˆçš„æ•°æ®ç»“æ„æ¥è·Ÿè¸ªæ¯å±‚çš„ç»“ç‚¹ï¼Œæˆ‘åœ¨ä¸‹é¢çš„é¢˜ç›®é‡Œä¹Ÿä¼šç”¨åˆ°ç±»ä¼¼çš„æ‰‹æ®µ

---

å¤§æ¦‚äº†è§£æ ‘å’ŒäºŒå‰æ ‘åæˆ‘ä»¬æ¥é€šè¿‡å‡ ä¸ªé¢˜ç›®çœ‹çœ‹æ€ä¹ˆå¤„ç†æ ‘çš„é—®é¢˜
===

## [leetcode 226 åè½¬äºŒå‰æ ‘](https://leetcode.com/problems/invert-binary-tree/)
è¿™ä»£ç éå¸¸ç®€å•ï¼Œåªæ˜¯åœ¨ååºéå†çš„åŸºç¡€ä¸Šé€’å½’çš„æ›¿æ¢å·¦å³å­æ ‘çš„ä½ç½®ã€‚
```c
node_t *invertTree(node_t *root)
{
        if (!root) {
                return NULL;
        }

        node_t *left  = invertTree(root->left);

        node_t *right = invertTree(root->right);

        root->left = right;
        root->right = left;

        return root;
}
```
å¦‚æœä½ å¯¹è¿™ä¸ªä»£ç æœ‰ç–‘æƒ‘ä½ å¯èƒ½éœ€è¦äº†è§£ä¸€ä¸‹å…³äºé€’å½’çš„äº‹æƒ…ã€‚

## [leetcode 116 Populating Net Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/)
æˆ‘ä»¬ç»§ç»­è§£è¿™ä¸ªé—®é¢˜ã€‚
è¿™ä¸ªé¢˜ç›®çš„éš¾åº¦ä¹Ÿä¸æ˜¯å¾ˆå¤§ï¼Œé¢˜ç›®è¦æ±‚æˆ‘ä»¬ä¿æŒå‰åºéå†çš„é¡ºåºã€‚è‡ªç„¶å¯ä»¥æƒ³åˆ°ä½¿ç”¨å‰åºéå†çš„é€»è¾‘å…ˆéå†æ•´ä¸ªæ ‘ã€‚
![tree](/assets/20250314_leetcode116.jpg)
é¢˜ç›®è¦æ±‚æ„é€ ä¸€æ£µæ–°çš„æ ‘ï¼Œå¾ˆè‡ªç„¶çš„å°±èƒ½æ³¨æ„åˆ°ï¼Œç»™å‡ºçš„å‡½æ•°ç­¾åæ˜¯æ²¡æ³•ä½¿ç”¨çš„ã€‚è¿™æ—¶å€™å¯ä»¥æ€è€ƒä¸€ä¸‹è¿™ä¸ªé—®é¢˜æ˜¯ä¸æ˜¯ä¸€ä¸ªé€’å½’å­é—®é¢˜ï¼Œ
ä¸€æ£µæ ‘æƒ³è¦flattenï¼Œå°±ç­‰äºè¿™ä¸ªæ£µæ ‘çš„å·¦å­æ ‘çš„flattenè¿æ¥å³å­æ ‘çš„flattenå°±å¥½äº†ã€‚

æ‰€ä»¥è¿™ä¸ªé—®é¢˜æ˜¯æœ‰é€’å½’å­é—®é¢˜çš„ï¼Œå½“ç¢°åˆ°å¶å­ç»“ç‚¹çš„æ—¶å€™å°±è¿”å›ç»“ç‚¹æœ¬èº«å¹¶åœæ­¢é€’å½’ã€‚
æˆ‘å¦‚ä¸‹ä»£ç å°±æ˜¯åŸºäºå¦‚æ­¤æ¦‚å¿µå†™ä¸‹æ¥çš„ã€‚
```c
node_t *connect(node_t *node1, node_t *node2)
{
        if (!node1) {
                return node2;
        } else if (!node2) {
                return node1;
        }
        if (node1 && node2) {
                node_t *curr = node1;
                while (curr->right)
                        curr = curr->right;
                curr->right = node2;
                return node1;
        }
        return NULL;
}

node_t *flatten_tree(node_t *root)
{
        if (!root) {
                return NULL;
        }
        node_t *left = root->left;
        node_t *right = root->right;
        if (left || right) {
                root->right = connect(flatten_tree(left), flatten_tree(right));
                root->left = NULL;
        }
        return root;
}

void flatten(node_t *root)
{
        if (!root)
                return;
        flatten_tree(root);
}
```
äº†è§£äº†è¿™ä¸€ç§è§£æ³•ï¼Œæˆ‘ä»¬ä¸€èµ·çœ‹ä¸€ä¸‹åˆ«çš„è§£æ³•

```c
void flatten(struct TreeNode* root) {
    if (root) {
        /* Move the left node to the right node */
        struct TreeNode* temp = root->right;
        root->right = root->left;
        root->left = NULL;
        struct TreeNode* node = root;
        
        /* Move to the end of the prev left node which is the new right node */
        while (node->right) {
            node = node->right;
        }
        
        /* Append the right node to its end */
        node->right = temp;
        
        flatten(root->right); 
    }
    return;
}
```
è¿™ä¸ªè§£æ³•çš„é€»è¾‘å’Œæˆ‘ä¸Šæ–‡çš„å†™æ³•å·®ä¸å¤šï¼Œæˆ‘ä¸Šæ–‡çš„å†™æ³•å¾ˆæ¸…æ¥šã€‚

ä¸‹ä¸€ä¸ªè§£æ³•
```c
struct Stack
{
    struct TreeNode* arr[2000];
    int top;
};

void push(struct Stack* s, struct TreeNode* node)
{
    s->arr[++(s->top)] = node;
}

struct TreeNode* pop(struct Stack* s)
{
    return s->arr[(s->top)--];
}

void stackNodes(struct Stack* s, struct TreeNode* root)
{
    if(root==NULL)
        return;
    push(s, root);
    stackNodes(s, root->left);
    stackNodes(s, root->right);
}

void flatten(struct TreeNode* root) {
    if(root==NULL)
        return;
    struct Stack s;
    s.top = -1;
    stackNodes(&s, root);
    struct TreeNode* curr = pop(&s);
    struct TreeNode* temp = NULL;
    curr->left = NULL;
    curr->right = temp;
    while((s.top)>-1)
    {
        temp = curr;
        curr = pop(&s);
        curr->left = NULL;
        curr->right = temp;
    }
}
```
è¿™ä¸ªé€»è¾‘ç®€å•è¯´å°±æ˜¯ä½¿ç”¨å‰åºéå†æŠŠæ ‘çš„ç»“ç‚¹æ”¾å…¥æ ˆä¸­ï¼Œç„¶åå‹å‡ºæ ˆæ¥å¤„ç†ã€‚å…¶å®æ— è®ºæ˜¯ç¬¬ä¸€ç§è¿˜æ˜¯ç¬¬äºŒç§æƒ…å†µéƒ½æ˜¯ä¸€ç§éšå¼çš„ä½¿ç”¨
æ ˆçš„ï¼Œä»–ä»¬ä½¿ç”¨çš„æ˜¯è°ƒç”¨æ ˆæ¥ä¿å­˜ä¿¡æ¯ã€‚æ‰€ä»¥è¿™ä¸‰è€…çœ‹ä¼¼ä¸åŒå…¶å®æ ¸å¿ƒé€»è¾‘å‡ ä¹ç›¸åŒã€‚

## [leetcode 654 Maximum Binary tree](https://leetcode.com/problems/maximum-binary-tree/description/) 
è¿™ä¸ªå¾ˆç®€å•ï¼Œæ²¡ä»€ä¹ˆéœ€è¦èŠçš„ï¼Œå¤„ç†å¥½å·¦å³å­æ ‘å°±å¯ä»¥é€’å½’çš„è§£å†³äº†ã€‚
```c
int find_bigest(int *nums, int numsSize)
{
        int big_index = 0;
        int i = 0;
        for (; i < numsSize; i++) {
                if (nums[i] > nums[big_index]) {
                        big_index = i;
                }
        }
        return big_index;
}

node_t *constructMaximumBinaryTree(int *nums, int numsSize)
{
        if (numsSize == 0) {
                return NULL;
        }
        int index = find_bigest(nums, numsSize);
        node_t *res = malloc(sizeof(node_t));
        int *val = malloc(sizeof(int));
        *val = (int) nums[index];

        if (numsSize <= 1) {
                res->value = val;
                return res;
        } else {
                int *left_nums = nums;
                int left_size = index;
                int *right_nums = nums + index + 1;
                int right_size = numsSize - left_size - 1;

                res->value = val;
                res->left = constructMaximumBinaryTree(left_nums, left_size);
                res->right = constructMaximumBinaryTree(right_nums, right_size);

                return res;
        }
}
```

ä¸‹é¢æ˜¯æ›´å¿«çš„ç®—æ³•ã€‚æˆ‘ä»¬è¯•ç€åˆ†æä¸€ä¸‹ï¼Œ

```c
struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize) {
    struct TreeNode* root = calloc(1, sizeof(struct TreeNode));
    struct TreeNode* curr = root ;

    root->val = *nums;
    root->left = NULL;
    root->right = NULL;

    for (int i = 1; i < numsSize; i++) {
        int val = *(nums + i);
        if (val > root->val) {
            struct TreeNode* node = calloc(1, sizeof(struct TreeNode));
            node->val = val;
            node->left = root;
            node->right = NULL;
            root = node;
        } else {
            bool updated = false;
            curr = root;
            while (curr->right != NULL) {
                if (val > curr->right->val) {
                    struct TreeNode* node = calloc(1, sizeof(struct TreeNode));
                    node->val = val;
                    node->left = curr->right;
                    node->right = NULL;
                    curr->right = node;
                    updated = true;
                    break;
                } else {
                    curr = curr->right;
                }
            }
            if (!updated) {
                struct TreeNode* node = calloc(1, sizeof(struct TreeNode));
                node->val = val;
                node->left = NULL;
                node->right = NULL;
                curr->right = node;
            }
        }
    }

    return root;

}
```
## [leetcode 105 Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
è¿™é¢˜å¾ˆæœ‰è¶£ï¼Œé€šè¿‡å‰åºéå†å’Œä¸­åºéå†ï¼Œæ„Ÿå—ä¸åŒç§éå†çš„ä½ç½®å…³ç³»å­˜å‚¨çš„ä¸åŒã€‚
1. ä¸ºä»€ä¹ˆå•ä¸€éå†çš„ä¸²æ²¡æ³•å”¯ä¸€çš„è¿”å›ä¸€ä¸ªæ ‘?
2. å‰åºéå†å’Œä¸­åºéå†æœ‰ä»€ä¹ˆç‰¹ç‚¹?

```c
node_t *buildTree(int *preorder,
                  int preorderSize,
                  int *inorder,
                  int inorderSize)
{
        if (preorderSize <= 0) {
                return NULL;
        }
        node_t *last_node = NULL;
        node_t *root = calloc(1, sizeof(node_t));
        int *rval = malloc(sizeof(int));
        *rval = preorder[0];
        root->value = rval;

        int index = 0;
        for (int i = 0; i < inorderSize; i++) {
                if (inorder[i] == *rval) {
                        index = i;
                        break;
                }
        }
        int *l_preo = preorder + 1;
        int l_preo_sz = index;

        int *r_preo = preorder + index + 1;
        int r_preo_sz = preorderSize - index - 1;

        int *r_inordero = inorder + index + 1;
        int r_inorder_sz = inorderSize - index - 1;

        root->left = buildTree(l_preo, l_preo_sz, inorder, index);
        root->right = buildTree(r_preo, r_preo_sz, r_inordero, r_inorder_sz);
        return root;
}
```

## [leetcode_106 Construct Binary Tree from Inorder and Postorder Traversal][](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
è¿™é“é¢˜æ˜¯ç”¨ååºéå†å’Œä¸­åºéå†æ¥æ„é€ ï¼Œé€»è¾‘å·®ä¸å¤šï¼Œä¸‰ç§éå†æ„é€ ç»“æŸä¹‹åä¼šä¸€èµ·è¯´ã€‚
```c
node_t *buildTree(int *inorder,
                  int inorderSize,
                  int *postorder,
                  int postorderSize)
{
        if (inorderSize == 0)
                return NULL;
        node_t *root = calloc(1, sizeof(node_t));
        int *valp = malloc(sizeof(int));
        *valp = postorder[postorderSize - 1];
        root->value = valp;

        int index = 0;
        for (int i = 0; i < inorderSize; i++) {
                if (inorder[i] == *valp) {
                        index = i;
                        break;
                }
        }
        int *r_in = inorder + (index + 1);
        int r_insz = inorderSize - index - 1;

        int *r_post = postorder + index ;
        int r_postsz = postorderSize - index - 1;

        int *l_in = inorder;
        int l_insz = index;

        int *l_post = postorder;
        int l_postsz = index;
        root->right = buildTree(r_in, r_insz, r_post, r_postsz);
        root->left = buildTree(l_in, l_insz, l_post, l_postsz);
        return root;
}
```
## [leetcode 889 Construct Binary Tree from Preorder and postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

```c
node_t *constructFromPrePost(int *preorder,
                             int preorderSize,
                             int *postorder,
                             int postorderSize)
{
        if (postorderSize == 0)
                return NULL;
        node_t *root = calloc(1, sizeof(node_t));
        int *valp = malloc(sizeof(int));
        *valp = postorder[postorderSize - 1];
        root->value = valp;

        if (postorderSize == 1) {
                root->left = NULL;
                root->right = NULL;
                return root;
        }
        int right_val = postorder[postorderSize - 2];
        int index = 0;
        for (int i = 0; i < preorderSize; i++) {
                if (preorder[i] == right_val) {
                        index = i;
                        break;
                }
        }
        int *l_pre = preorder + 1;
        int l_pre_sz = index - 1;
        int *l_post = postorder;
        int l_post_sz = index - 1;

        int *r_pre = preorder + index;
        int r_pre_sz = preorderSize - index;
        int *r_post = postorder + (index - 1);
        int r_post_sz = postorderSize - index;

        root->left = constructFromPrePost(l_pre, l_pre_sz, l_post, l_post_sz);
        root->right = constructFromPrePost(r_pre, r_pre_sz, r_post, r_post_sz);
        return root;
}
```
ä»¥ä¸Šä¸‰ä¸ªé¢˜ç›®åˆ†åˆ«ä½¿ç”¨éå†ä¿¡æ¯å¾—å‡ºä¸€æ£µæ ‘ï¼Œå‰åº+ä¸­åºã€ååº+ä¸­åºéƒ½æ˜¯å¯ä»¥å¾—åˆ°å”¯ä¸€çš„æ ‘ï¼Œ
ä½†å‰åº+ååºæ˜¯æ²¡æ³•å¾—å‡ºå”¯ä¸€çš„æ ‘ã€‚
å‰åºå’Œååºéå†æ˜¯æ²¡æ³•æŠŠç¡®è®¤å·¦å³å­æ ‘çš„ï¼Œå”¯æœ‰ä¸­åºéå†å¯ä»¥åˆ†è¾¨å·¦å³å­æ ‘ã€‚æ‰€ä»¥å‰åºå’Œååºéå†æ²¡æ³•å”¯ä¸€ç¡®å®šä¸€ä¸ªæ ‘ã€‚



## [leetcode_912 sort an array](https://leetcode.com/problems/sort-an-array/description/)
è¿™é¢˜çš„éš¾ç‚¹æ˜¯ä½¿ç”¨æ—¶é—´å¤æ‚åº¦å°äº$\mathcal{O}(nlog(n))$çš„æ’åºç®—æ³•
è¿™é¢˜æˆ‘ä½¿ç”¨merge sortæ¥æ¼”ç¤ºï¼Œmerge sortæœ¬è´¨ä¸Šæ˜¯åœ¨é—®é¢˜åŸŸä¸­ä½¿ç”¨ç¼©å°é—®é¢˜çš„æ–¹å¼ï¼ŒæŠŠå¾…å¤„ç†çš„æ•°æ®ä»¥æ ‘çš„ç»“æ„åˆ†è§£ï¼Œä¹‹åå†ä¾æ¬¡åˆå¹¶ï¼Œè¿™æ ·å¯ä»¥æœ‰æ•ˆçš„æ§åˆ¶æ—¶é—´å¤æ‚åº¦å†ç›®æ ‡ä»¥å†…ã€‚

```c
int *sort(int *left, int left_sz, int *right, int right_sz)
{
        int res_sz = left_sz + right_sz;
        int *res = calloc(res_sz, sizeof(int));
        int res_count = 0;

        int i = 0;
        int j = 0;

        while (i < left_sz || j < right_sz) {
                if (i == left_sz) {
                        while (j < right_sz) {
                                res[res_count] = right[j];
                                res_count++;
                                j++;
                        }
                        return res;
                } else if (j == right_sz) {
                        while (i < left_sz) {
                                res[res_count] = left[i];
                                res_count++;
                                i++;
                        }
                        return res;
                }

                if (left[i] < right[j]) {
                        res[res_count] = left[i];
                        res_count++;
                        i++;
                } else {
                        res[res_count] = right[j];
                        res_count++;
                        j++;
                }
        }

        return res;
}

int *merge_sort(int *nums, int size)
{
        if (size == 0)
                return NULL;
        int *res = NULL;
        if (size == 1) {
                /* int *res = calloc(1, sizeof(int)); */
                /* *res = *nums; */
                /* return res; */
                return nums;
        }
        int mid = size / 2;

        int left_sz = mid;
        int right_sz = size - mid;
        int *left = merge_sort(nums, left_sz);
        int *right = merge_sort(nums + mid, right_sz);

        res = sort(left, left_sz, right, right_sz);

        return res;
}

int *sortArray(int *nums, int numsSize, int *returnSize)
{
        int *res = merge_sort(nums, numsSize);
        *returnSize = numsSize;
        return res;
}
```
merge sortæ²¡æœ‰ä»€ä¹ˆéš¾ç‚¹ï¼Œä»ä»£ç å½¢å¼ä¸Šçœ‹merge sortæ˜¯ä¸€ç§å¯¹é—®é¢˜æ ‘çš„ååºéå†ã€‚è¿™ä¸ªç®—æ³•çš„å…³é”®æ˜¯æœ‰åºæ•°ç»„çš„åˆå¹¶ã€‚


## å¼•ç”¨
[æ•°æ®ç»“æ„çš„ç½‘ç«™](https://epaperpress.com/sortsearch/has.html)

## å
è¿™å‘¨æœ‰äº›ä¸èˆ’æœï¼Œæ²¡æœ‰å®Œæˆæ ‘çš„å¾ˆå¤šèƒŒæ™¯çŸ¥è¯†ï¼ŒäºŒå‰æœç´¢æ ‘å’Œåˆ«çš„æ ‘çš„ä»‹ç»å¾—ä¸‹å‘¨æ‰è¡Œäº†ã€‚
è¿™å‘¨åªæ˜¯ä»‹ç»äº†äºŒå‰æ ‘çš„éå†æ–¹å¼ï¼Œå¦‚æœè®©æˆ‘ä¸€å¥è¯æ¦‚æ‹¬ä¸€ä¸‹ï¼Œæ ‘å’Œé€’å½’æœ‰å¾ˆå¼ºçš„è”ç³»ï¼Œä»æŸç§ç¨‹åº¦ä¸Šè¯´ï¼Œé€’å½’æœ¬èº«å°±æ˜¯ä¸€ç§æ ‘ã€‚
æ ‘ç›¸å…³çš„é¢˜ç›®éš¾åº¦å¾ˆä½ï¼ŒåŸºæœ¬ä¸Šå¯ä»¥é€šè¿‡éå†æ ‘çš„æ–¹å¼å’Œå»ºç«‹é€’å½’ï¼Œè¿™ä¸¤ç§æ–¹å¼è§£å†³ã€‚ä¸‹å‘¨ä¼šè¯¦ç»†ä»‹ç»æ›´å¤šçš„æ ‘çš„ç±»å‹ï¼Œä»–ä»¬å„è‡ªæœ‰å„è‡ªçš„
æ€§è´¨ï¼Œè¿™äº›æ€§è´¨ä¿è¯äº†ç®—æ³•çš„æ€§è´¨ã€‚éœ€è¦çš„æ˜¯ç†è§£è¿™äº›æ€§è´¨ã€‚

Sun Mar 16 10:26:58 PM CST 2025
