---
layout: post
title: "Mermaid 图在 MDX 中水合失败的根因分析与工程复盘"
date: 2025-04-18
categories: [RCA]
tags: [RCA]
---
<Capture_image src="/assets/20250418_RCA_on_mermaid.png" alt="alt-test" capture="Root cause Analysis" />

## Mermaid 图在 MDX 中水合失败的根因分析与工程复盘

> _"技术问题终将解决，重要的是我们是如何面对它的。"_

这是一篇记录我在迁移博客系统过程中，解决 Mermaid 图在 MDX 渲染中出现 hydration mismatch（React 水合错误）问题的过程分析与经验总结。它不仅是一份技术笔记，也是一份反思式的成长记录。

---

### 🧩 问题起因：博客系统迁移中的意外挑战

我从 GitHub Pages + Jekyll 的博客系统迁移到 Vercel + Next.js，目的是为了更好地支持 React 组件、实现内容复用，以及未来添加交互组件（如图表）。

迁移过程中我遇到一个关键挑战：**如何让原来 Markdown 中使用的 Mermaid 图表，在新的 MDX 构建链中正常显示？**

#### ❓ 症状
- MDX 文件中使用 Mermaid 图表时，页面加载出现 React hydration mismatch
- Mermaid 图未正确渲染，页面 DOM 被二次修改

当时我还不理解什么是 MDX 的 "rsc"（React Server Component）机制，也没意识到 Mermaid 的 SVG 是运行时生成的。

---

### 🔍 初始判断与误导路径

#### ✅ 合理假设：
我初步判断问题在于：**SSR 与 CSR 在渲染 Mermaid 图时产生差异**。

#### 🧨 被误导路径：
我在搜索“mermaid + react”时找到了一个 demo。它使用 `useEffect` 动态插入 Mermaid SVG，运行正常。

于是我误以为：
> “Mermaid 渲染就是这么做的，那我复制这段代码就可以解决。”

然而这段 demo 默认运行在 CSR 环境（纯客户端），并不适配 MDX SSR 构建链 —— 它掩盖了真正的底层机制。

回头看，其实我应该直接去 Mermaid 官方文档中确认其推荐的渲染方式和环境依赖。

---

### 🧭 分析过程：掉入 SSR / RSC / Hydration 的迷宫

我开始尝试理解几个核心概念：

- 什么是 React hydration？为什么会 mismatch？
- Next.js 的 server component 和 client component 是如何区分的？
- `next-mdx-remote/rsc` 到底是怎么工作的？

#### ⚠️ 分析盲区：
我当时并没有梳理清楚信息优先级，而是看到什么文档就看什么 demo，试图“碰巧撞到答案”。

这也暴露出我当时“用 demo 驱动解决问题”的惯性思维 —— 它有效率，但面对系统性新技术时并不稳健。

---

### ✅ 最终方案：退一步，海阔天空

我尝试了使用 Puppeteer、Playwright 等无头浏览器，在构建阶段把 Mermaid 渲染为 SVG。但：

1. 这需要重构 Next 构建流程，引入额外浏览器上下文，极其复杂
2. 即使能成功，也增加了极大构建时间和维护成本

于是我退了一步：

> "我真的需要在服务器上渲染 Mermaid 吗？"

答案是不需要。反而可以把 Mermaid 图包装成 `use client` 的 React 组件，用 `useEffect` 来挂载 Mermaid 渲染逻辑，**让它在客户端安全生成 SVG**。

#### 🎉 结果：
- 解决了 hydration mismatch 问题
- 保持了页面的静态生成能力
- 为后续的动画增强留出了空间

---

### 🌱 经验提炼：从 demo 思维到结构性思考

#### ✅ 结构性收获：
- 在遇到水合问题时，先明白 React SSR 与 CSR 的边界，再定位实际 HTML 差异
- 不要用 demo 替代原理理解，尤其是涉及构建链的技术（如 MDX）
- RSC 与 CSR 的组件混用时，需要特别注意副作用 timing（如 Mermaid 的 DOM 替换）

#### 🧠 元认知成长：
- 当我发现自己“在一个方向上花了很久没结果”，开始有意识地停下来复述问题，用讲述的方式做问题重构
- 给朋友讲问题，是一种“反馈放大镜”，能让我意识到“我是不是跑偏了”

---

### 🔍 方法论小结：我学会了什么？

| 阶段 | 做得好 | 可以改进 |
|------|---------|------------|
| 初始判断 | 快速找到 SSR/CSR 问题核心 | 忽视了 Mermaid 的官方文档说明 |
| 调查过程 | 学会了 hydration 的原理 | 缺乏信息优先级，过度依赖 demo |
| 问题解决 | 成功退回 client 组件方案，问题闭环 | 在无头浏览器尝试上浪费时间过多 |
| 心态管理 | 学会停下来讲问题，获得反馈 | 未来要更快判断“什么时候该退出某条路” |

---


<Expanded_info name="根因分析: Mermaid 在MDX中水合失败的问题过程">
1. 问题描述
    * 我这次遇到的核心问题，如何迁移之前的markdown文件到新的博客系统里？
    * 症状 不熟新的框架和发布系统，没有本质了解MDX和md文件的区别。

2. 初始假设与方向
    * 我第一时间判断可能问题出在服务端渲染和客户端渲染合作上。
    * 我第一时间搜索了mermaid+react得到一个demo代码，这个代码的确对我有一些误导，让我认为
        mermaid的渲染方式只有一种，但现在回顾看，应该查看mermaid的官网看他们有没有暴露渲染方式

3. 分析与调查过程
    * 还是搜索水合是什么意思，什么情况会导致水合。但当时我没有理解next的服务器组件和客户端组件的逻辑，也叠加了对MDX-rsc的误解（认为在其中的所有组件都是服务器组件），
    * 优先级的确很少触及，还是发现什么就看什么，我觉得这一个步骤的问题在于我没有深入了解不一样，试图通过一些表面的demo去处理问题。

4. 最终解决方案
    * 我最后发现全部在服务端渲染mermaid会需要无头浏览器需要浏览器环境，这样又引入了浏览器的变量，并且我没有成功尝试使用无头浏览器库和next框架融合。的确在无头浏览器
      的配置和学习中花了一些时间这个也许是不需要的。现在我是使用了一开始就想到的使用client
      组件的方式来渲染组件这样就解决了水合问题。我认为这个逻辑算是根本的解决了水合问题，而且还为之后客户端做一些动画优化留出了空间。
    * 有没有留下技术债，没有。这次问题算是比较完美的解决了。
5. 经验提炼
    * 我发现server 组件这个路子也许不能走了之后，没有一直钻牛角尖，而是再想想是不是有更简单和更好的解决方案，这里我是通过给一个朋友打电话描述情况，通过他的反映来再次反馈
      给我自己让我发现我是不是走的太远已经偏离主体了。碰到水合问题，如果不理解是什么第一件事情需要知道它是什么为什么会出现，然后才能比较容易缩小问题范围。
    * 我觉得我在一个分支上工作很久都没有解决问题说明这条路线大概率是有问题的，只是我现在还没有掌握到底要工作多久。
6. 结构性反思
    * 我觉得我可以停下来再描述问题这件事是我之前不会做的，它也是这次问题可以解决的关键。
    * 应该就是直接判断client组件没办法渲染mermaid，是我想简单了。而觉得server组件才能处理是我想复杂了。

</Expanded_info>


## 后

这次问题看似是“一个前端图表渲染 bug”，其实让我理解了很多 Next.js 的设计哲学：

- SSR 不一定万能，很多时候客户端执行才是合适场景
- 技术选型不能一味追求“看起来最先进”，要服务于问题本身


_2025 年 4 月 · 博客系统迁移日志整理_

Fri Apr 18 11:27:24 AM CST 2025
