---
layout: post
title: "🐸 Frog OS 调试日志02"
date: 2025-04-20
categories: []
tags: []
---

# 启动流程与 GDB 断点问题追踪

**时间范围：** 2025年4月17日 ～ 2025年4月19日\
**关键词：** QEMU, GDB, KVM, Bootloader, Paging, Page Directory, Page Table

---

## 🧠 背景

调试 Frog 操作系统的启动过程：

```text
BIOS → Bootloader (0x7C00)
        ↓ 读取 kernel 到 0xC4000
        ↓ 开启保护模式
        ↓ 启用分页机制
Kernel Entry @ 0xC0070000
```

分页在进入 `UkiMain` 之前完成，涉及初始化页目录、页表，并将虚拟地址映射到物理地址。

---

## 🧭 分页机制结构概览

### 🗂 页目录结构（Page Directory）

| PDE Index (Dec) | PDE Index (Hex) | 虚拟地址范围                    | 映射状态       | 用途           |
| --------------- | --------------- | ------------------------- | ---------- | ------------ |
| `0`             | `0x000`         | `0x00000000 ~ 0x003FFFFF` | ✅ 已映射 pg0  | 用户态/内核共享映射区  |
| `1~767`         | `0x001~0x2FF`   | `0x00400000 ~ 0xBFFFFFFF` | 🚫 未映射     | 用户空间预留       |
| `768`           | `0x300`         | `0xC0000000 ~ 0xC03FFFFF` | ✅ 映射 pg0   | 内核起始虚拟地址     |
| `769~1022`      | `0x301~0x3FE`   | `0xC0400000 ~ 0xFFBFFFFF` | ✅ 映射 pg1\~ | 内核剩余虚拟地址区域   |
| `1023`          | `0x3FF`         | `0xFFC00000 ~ 0xFFFFFFFF` | 🚫 保留      | 预留作自映射或异常页防护 |

- 每项 PDE 映射 4MB 虚拟地址
- 256 项页目录项总共可以映射 1GB 虚拟地址（用于内核）
- 当前使用 254 项 (`769~1022`) + 第 768 项 + 第 1023 项 = **256 × 4MB = 1024MB**，全部映射完成

---

### 📦 页表结构（Page Table `pg0`）

```text
pg0[0]   = 0x00000000 | flags  → 映射到物理地址 0x00000000
pg0[1]   = 0x00001000 | flags  → 映射到物理地址 0x00001000
...
pg0[255] = 0x000FF000 | flags  → 映射到物理地址 0x000FF000
pg0[256~1023] = 未初始化（无映射）
```

页表 `pg0` 提供了连续的物理内存 0\~1MB 映射，虚拟地址从：

- `0x00000000 ~ 0x000FFFFF`（用户低地址段）
- `0xC0000000 ~ 0xC00FFFFF`（内核高地址影子映射）

---

## 📌 特殊项说明

- `PAGE_DIR[1023]` 被保留：
  - 可以用于**自映射页表结构**：让 `0xFFFFF000` → 页目录自身，实现页表数组化访问。
  - 或者保留为空，作为页访问保护用途。

---

## ✅ 当前分页状态图解

```
  虚拟地址空间 (4GB)
  ┌─────────────────────────────┐
  │ 0xFFFFF000  → 保留 / 自映射 │ ← PDE[1023 / 0x3FF]
  │   ...                       │
  │ 0xC0400000  → pg1           │ ← PDE[769 / 0x301]
  │ 0xC0000000  → pg0           │ ← PDE[768 / 0x300]  ← 映射物理 0x0 ~ 1MB
  │   ...                       │
  │ 0x00000000  → pg0           │ ← PDE[0 / 0x000]
  └─────────────────────────────┘
```

---

## 🎯 自映射机制图解（预设设计）

```text
// 目标：构建一个便于内核读取页表结构的自映射区域

// 步骤：
1. PDE[1023] = 页目录的物理地址 | flags
2. 那么：
   - 虚拟地址 0xFFFFF000 → PDE 自身（Page Directory）
   - 虚拟地址 0xFFC00000 ~ 0xFFFFEFFF → 所有 Page Table（1024×4KB）

// 举例：
  PDE[0]    → 0xFFC00000      → pg0 的内容
  PDE[768]  → 0xFFC00000 + 768×4KB = 0xFFF00000

可由以下宏或访问方式简化：
- `PDE_VA = 0xFFFFF000`
- `PTE_VA(pde_index) = 0xFFC00000 + (pde_index << 12)`
```

作用：

- 使得操作系统可直接以内存访问方式，动态读写当前页目录 / 页表内容
- 允许快速构造 `get_pte(vaddr)` / `map_page(vaddr, paddr)` 等页表管理函数

---

## 🔧 如何基于 PDE[1023] 完善自映射机制

> 自映射机制的核心哲学：用页目录的最后一个条目（PDE[1023]）来指向整个页目录本身，从而实现“页表的页表”。这里有一个补充，这里是把页目录表当作页表使用。

### ✨ 自映射后的访问能力：

- 页目录的虚拟地址：`0xFFFFF000`
- 所有页表的虚拟起始地址：`0xFFC00000`
- 某个虚拟地址 vaddr 的对应 PTE 地址：
  ```c
  uint32_t* get_pte(uint32_t vaddr) {
      uint32_t pde_idx = vaddr >> 22;
      uint32_t pte_idx = (vaddr >> 12) & 0x3FF;
      uint32_t* pte_base = (uint32_t*)(0xFFC00000 + (pde_idx << 12));
      return &pte_base[pte_idx];
  }
  ```

### 🛠 开启方式：

只需一行汇编：

```asm
mov eax, PAGE_DIR_START | 0x7   ; 设置 Present、RW、User 标志位
mov [PAGE_DIR_START + 1023*4], eax  ; 直接写入页目录表的最后一个 PDE（即自映射）
; 由于之前已经为页表分配好内存，所以可以直接通过虚拟地址访问 PAGE_DIR_START，即页目录本身
```

然后刷新页目录：

```asm
mov eax, PAGE_DIR_START
mov cr3, eax
```

> ✅ 从此以后，系统可以用普通指针操作页表：无需维护物理地址映射，也不再需要特别的分配表结构。

### 🧠 优点：

- 映射完美一致（不会因页目录和页表分离而逻辑断裂）
- 能直接构建分页分配器、用户空间拷贝等基础设施
- 是现代操作系统（包括 Linux）中默认使用的高级机制之一

---

## 🧩 深入理解内核态分页机制设计哲学与约束边界

分页不仅是技术机制，也承载着对系统结构的**理解方式**。Frog OS 的分页实现已经体现出如下哲学性思考：

### ✅ 1. **抽象隔离与特权边界**

- 内核空间从 `0xC0000000` 开始，是虚拟地址上的“特权世界”
- 用户空间无法访问高地址页（PDE[768+]），这是安全策略的基础
- 这种设计承认虚拟地址不只是地址，而是“访问权限的地图”

### ✅ 2. **身份映射的哲学地位**

- 将 `0x00000000 ~ 1MB` 同时映射到 `0x00000000` 和 `0xC0000000`，是一种折叠现实的方式：
  - 内核可以无障碍访问 Bootloader 初始化的结构
  - 用户态不会感知真实物理结构

### ✅ 3. **自映射：操作系统的“元语言”**

- `PDE[1023]` 让操作系统得以用**虚拟地址操作页表本身**，实现页表即数据结构
- 是系统对自身结构的反身引用（reflective structure）

### ✅ 4. **约束条件下的极简布局**

- Frog 仅使用 `1MB` 映射、`254` 个页表、1 个共享 `pg0`，在资源紧张下极简实现了完整内核地址空间
- `PAGE_DIR[1023]` 暂未激活，也是保留设计哲学的体现：为未来扩展留钩子

---

## 🔍 Frog 页表机制与 Linux 三层页表结构的比较

虽然 Frog 使用的是传统的 **二级分页结构**（页目录 → 页表 → 页），但通过**自映射机制**，可以模拟出类似 Linux 的三级结构特性。

### Linux 的三级页表结构：

- **PGD（Page Global Directory）**
- **PUD（Page Upper Directory）** → 4KB 页模式下为 NULL，占位用
- **PMD（Page Middle Directory）**
- **PTE（Page Table Entry）**

### Frog 的结构映射：

| Linux 层级 | Frog 对应                    |
| -------- | -------------------------- |
| PGD      | 页目录（Page Directory）        |
| PMD      | 无（或通过页目录中分段模拟）             |
| PTE      | 页表（Page Table）             |
| 自映射能力    | 通过 PDE[1023] 完成反射访问，实现多级维护 |

📝 若未来需要扩展为多级页表（例如 4GB+ 地址空间或进程隔离需求），Frog 可在 `PDE` 结构之上引入 “页目录指针表” 模拟更高层次，如同 x86-64 的 PML4/PDP。

---

## 后

这只是mm这个子系统的前置作业。之后还会有
- 如何基于自映射支持用户态内存页分配
- 如何从“页表可感知”过渡到“动态多级分页”
- 从分页机制构建权限系统与最小内核映射路径
- 如何实现多进程页目录隔离与写时复制（COW）

Sun Apr 20 01:17:58 PM CST 2025

