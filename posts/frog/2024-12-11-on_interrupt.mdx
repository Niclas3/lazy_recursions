---
title: 聊聊中断
updated: Wed Dec 11 12:15:59 CST 2024
categories : [program, os]
---

## 起因

我一直维护一个项目叫做`frog`，它是一个基于x86的32bits操作系统。最近想要 着手给他增加网络功能，在增加之前首先需要替换或者更新之前孱弱的中断系统，由于操作系统只需要使用三种外部中断，**时钟中断**，**键盘中断**和**鼠标中断**,秉着够用就行的原则我使用的是古老的**PIC**+**PIT**，**中断控制器(PIC)**提供中断控制，PIT提供时钟中断。现在需要支持网卡需要支持的设备越来越多,也许增加一个设备总线(PCI)是更好的选择。

中断作为一种通知机制，是硬件与CPU高效通信的重要手段，尤其是处理异步时间时表现出色。

## 作为通知机制的中断
中断是硬件和CPU交互的机制之一，除了中断还有**轮询**,**DMA**,**I/O映射**,**消息专递(MSI)**。中断是一种有效的通知机制，尤其是在需要快速响应的异步处理场景。中断可以直接打断CPU处理的当前问题执行指定任务(这个在OS里也有类似的机制，**抢占式多任务**)。中断也可以有优先级，通过一个PIC或者APIC，一种中断控制器来判断各种中断的优先级。

### Exception --- 同步中断(synchronous interrupt)
同步中断是由CPU发起的，当指令发生异常的时候则会触发同步中断，比如**缺页异常**，**除零异常**所以这个中断又被称之为**异常(exception)**, x86-32位，CPU提供一些默认的[exception](https://wiki.osdev.org/Exceptions)。

### Interrupt --- 非同步中断(asynchronous interrupt)
非同步中断是外部硬件在任意时间和CPU交互的手段，这也是本文着重的部分。

Intel 的文档是这样分类这两种中断的

* **Interrupt** 
  **可屏蔽中断(Maskable interrupt)**
  
    所有的I/O外设(外部硬件)发起的IRQs都是**可屏蔽中断**, 可屏蔽中断有**可以屏蔽**和**不可以屏蔽**两个状态。
    一般可执行中断都是会经过PIC(可编程中断控制器)传入CPU 。
    > 具体来说以x86-32架构就是**EFLAG**寄存器里的IF标识和PIC的**IMR(interrupt must register)**控制。这两个控制机制算是x86架构中的两级控制。
    
    **IMR（中断屏蔽寄存器）**属于PIC的一部分，负责屏蔽特定中断信号，不传入CPU。而**EFLAG**寄存器中的**IF**位，则用于CPU自身控制是否响应中断。
    > **IMR**配置和你的中断控制器有关，`frog`目前使用的是**8259A** 所以**IMR master**是
    `0x21`端口, **IMR slave**是`0xA1`端口。如果后续改成**APIC**就不需要**IMR**而是使用**APIC**提供的
    中断优先级和屏蔽机制管理**IRQ**。
    nasm语法就是`sti` 和`cli`。分别是设置屏蔽和清除屏蔽。

  **不可屏蔽中断(Nonmaskable interrupt)**
  
  重要的事件(比如硬件错误,内存控制器或者看门狗)会发起一些**不可屏蔽中断**,
NMI信号会**直接连接CPU**，而不通过PIC。
> 在intel文档vol-3 6.3.1节表格6-1展示了NMI interrupt的中断号是0x02
    
* **Exceptions**
    处理器监测到的异常(Processor-detected exceptions)
    
    Exceptions是CPU在运行指令的时候监测到的异常。这种异常是同步触发，这种异常是由操作系统异常处理代码处理的，这种异常通常是程序错误引起的。这种异常大概可以以是不是会被保存现场信息比如把`eip`这个寄存器存入**内核栈**。
    
    **Exceptions**分为3类**faults**,**traps** 和 **aborts**。
    
    在谈论Exception之前需要了解“**指令完成**”。**指令完成**指的是指令的所有步骤都执行完毕
     _**取指**、
     **解码**、
     **执行**、
     **写回**。_
     这个概念是CPU制造需要用到的具体可以下次聊CPU流水线来详细了解。
        
    * 错误(Faults)
    
        错误(Faults)是在指令**尚未完成**时触发的异常。
        这是一种可以被改正的异常，发现错误之后一旦被改正之后就可以恢复正常的**执行流**。当一个指令发生**Faults类型**的异常的时候会把**当前指令**的eip压栈保存起来，进入对应的异常处理程序，异常处理完成之后会从利用之前保存的eip中恢复原来的执行流，会从触发faults的指令开始执行。
        
        例如：**页面错误(page fault)**，**段错误(segment fault)**
    * 陷阱(Traps)
    
        **陷阱(Traps)**是在指令**已经完成**后触发的异常。
        这个陷阱和**software Interrupt**关系也不小，**software Interrupt**其实就是一个Traps类型的exception。Traps是一种不可以恢复的异常，一旦触发了traps那么**这条指令的下一条指令**的eip则会被押入栈中保存。异常处理结束后会接着下面的指令恢复原来的执行流。
        
        例如：x86-32 架构中有3个异常分别是**#DB**, **#BP**, **#OF(debug exception,
        breakpoint, overflow)**

        `#DB (debug exception)`
        这个既可以是**faults**也可以是**traps**，双重属性是为了提供断点，单步执行，数据观察。这个有很多功能之后写文章详细说明。

       `#BP (breakpoint Exception)`
        这个提供了断点为了设置断点。`int3`是x86专门设计的单字节中断指令(`0xCC`)

        `#OF (Overflow Exception)`
        这是为了检查算数操作的**溢出(Signed Overflow)**。`into`是为了直接出发这个**Traps**(这个很少用，算数溢出在应用层就会被捕获了很少到CPU还没处理的)

    * 终止(Aborts)
        这里只有发生非常严重的问题的同时还才会触发的一类异常。这时候有可能连eip或者栈都被破坏了。这是一种不可恢复的异常。
        
        Intel 提供了两种

        `#MC (Machine Check，机器检查)`
        某种严重的硬件故障。比如内存ECC校验失败。缓存一致性错误，总线传输错误，等其他不可恢复的硬件错误。这个需要读取硬件提供的MCA(Machine check architecture)寄存器获取具体错误原因。

        `#DF (Double fault，双重故障)`
        当CPU处理异常的时候又发生了异常。这个时候可以记录上下文信息。
        
* **Programmed exceptions**
    这个和软件中断(software interrupt)差不多，它也是由程序的指令生成的不是硬件事件引发的。他们有俩个指令`bound`, `into`。
    
    `into`已经讲过了。
    
    `bound`是为了检测数组或者数据范围是否超出指定边界
    **第一个操作数**是要检查的索引或者值
    **第二个操作数**是内存地址，包含两个边界值(低边界，高边界)
    如果寄存器的值小于低边界或者大于高边界，触发**#BR(bounds check exception)**
    
    ```
    bound reg, mem
    ```
中断向量一共256个，范围是0-255。

## 作为执行流的中断
**执行流**定义为一段正在执行的代码。
要知道一段正在执行的代码需要一些必要的外围环境作为支持。

1. **外围环境**(context)就是**栈**和
2. **cpu寄存器**来处理函数调用和一些局部变量的存储。

这次讨论着重考虑**栈**的作用，在一个OS主要有如下9种**执行流**,我会分别给出他们使用的**栈**。

![](/assets/forg_on_interrupt_processtable.png)


```
<!-- 
   类型                         栈类型
1. 普通进程(用户进程)           用户栈/内核栈
2. 内核进程                     内核栈

3. 中断处理程序(ISR)            内核栈/中断栈 \
4. 异常处理程序(exceptions)     内核栈        |  中断有关
5. 软中断(Softirqs&tasklets)    内核栈        |
6. 工作队列(work Queues)        内核栈        /

7. 信号处理程序   (*)           用户栈/信号栈
8. 异步I/O回调    (*)           用户栈/内核栈
9. 引导程序                     初始栈
-->
```

----

### 中断的处理流程与机制
#### 简要中断处理流程
```flow
hw=>operation: hardwares
cpu=>operation: CPU
pic=>operation: PIC
isr=>operation: ISRs
hw->pic->cpu->isr
```  

1. **硬件设备**通过中断信号线向**PIC**发出**IRQs(Interrupt ReQuests)**
2. **PIC**把中断号发送给**CPU**
3. **CPU**根据中断号查询**中断向量表(IVT/IDT)**执行对应的**中断服务程序(ISR)**
4. **CPU**向**PIC**发送处理完毕的**信号(EOI)**以便中断控制器可以接受别的信号

#### 硬件部分PIC(中断控制器)和硬件设备
     # 目前只考虑PIC的情况，如果之后Frog会支持APIC会补充APIC的新文章

聊中断硬件部分的时候我们需要两个硬件。一个是**发生硬件的设备**,这次我选网卡。还有一个是**PIC**。

PIC是**用来管理不同中断和CPU通信的中介**，主要负责
1. 接受中断请求。
2. 判断是否转发中断请求给CPU(屏蔽检查，优先级判断，服务中检查)
3. 发送中断服务到CPU 
4. 接受**EOI(End of Interrupt)**信号

> 我们假设一个网卡发出一个中断请求到PIC上，网卡和PIC是通过铜线相连。
> 1.PIC接受中断信号。
>     这时候PIC接受到网卡中断信号，中断请求记录在IRR(中断请求寄存器)中。
> 2.PIC判断是否通知CPU
>     此时PIC会进行一系列判断，决定是否将网卡中断转发给CPU：
>     1. **IMR(中断屏蔽寄存器)**检查：确认该中断是否被屏蔽。
>     2. **ISR(服务中寄存器)**检查：查看该类型中断是否正在服务中，且CPU尚未释放中断线（通过EOI）。
>     3. **优先级判断**：优先级更高的中断可以打断低优先级的中断
>     
> 3.PIC向CPU发送中断
>     一系列判断过后，如果可以发送中断给CPU，那么PIC就会通过中断向量号告诉CPU中
>     断类型(中断向量号是在PIC初始化的时候OS和PIC约定好的)。
> 4.CPU处理中断
>     这里的操作我会在内核处理部分详细说明。之后CPU处理中断后会发送EOI信号给PIC
> 5.PIC接受**EOI**信号
>     PIC会接受到EOI信号清除ISR的标志位，释放中断线。
> 6.PIC检查挂起的中断
>     之后PIC会检查挂起的中断，也就是刚刚因为ISR存在而没有被响应的中断，PIC检查IRR如果又挂起的中断就会继续通知CPU。
    
由刚刚的流程PIC在硬件层面已经做了一定程度的**优先级**和**同类型中断屏蔽**的功能。
    
值得一提的是，就网卡中断来说，如果网卡中断被挂起数据包会缓存在网卡上的缓冲区中
类似的硬件都有这种功能。

#### 内核处理部分 
CPU首先收到了来自PIC选择的中断,PIC传递来的是已经把**IRQs**线号转换后的中断向量号，(这是通过数据总线传输来的)intel的CPU有一个机制叫做**中断门**，CPU通过IDT(中断描述符表)CPU在得到这个中断向量后，使用中断向量号结合IDT查找到对应的中断处理程序的地址**ISR(interrput service routine)**。这时候就正式进入处理函数的部分，处理中断的流程以给PIC的端 口发送**EOI(end of interrupt)**为分界分为2个部分。

我们稍微把CPU时间往前拨动一点到，中断还没有从PIC发送到CPU时候。我们看看OS当时在做什么，这时候OS可能处于两种情况一种是工作在**Ring3**也就是**用户态**，一种是工作在Ring0也就是内核态，我挑选Ring3来解释。此时工作在用户态的操作系统由于中断的突然发生打断了当前的执行流，准备越过**中断门**进入IDT中记录的ISR的地址执行ISR。这时候由于CPU发现是**Ring3->Ring0**的权限提升所以需要借助**TSS(Task State Segment)**来切换当前使用的栈从ring3栈到ring0栈。CPU自动切换栈的同时，还把Ring3时的 `ss`, `esp`, `eflag` `cs`, `eip` 这5个寄存器的值依次压入了内核栈也就是ring0栈栈切换完毕，ring3的寄存器压入完毕之后，由于使用了中断门，所以`EFLAG`这个寄存器的`IF位`自动清零用来屏蔽可屏蔽中断，这些做完之后就正式进入目标中断向量号的ISR中开始处理中断。

##### ISR部分
由于**ISR**会处理很多数据所以会尽可能的保存现场。Frog的处理方式是在每一次**ISR**的时候都会**依次**压入`ds``es` `fs` `gs` `pushad` `push %INR`(最后一个是压入中断向量号)到内核栈中。
操作系统内核提供一个类似**IDT**一样的**ISR**的函数指针数组`intr_table`这里提供一些共用的代码(因为不同架构的CPU在中断处理上的汇编有所不同)。

在准备好环境之后，**ISR**需要做的工作是移动一些数据到内存中,和挂起一个对应中断的**softirq**，一旦这数据处理完毕ISR的工作就结束了。这是就可以调用`irq_exit()` 结束ISR的部分。

> `irq_exit()` 主要用处是给`PIC/APIC`发送**EOI**即调用`ack()`方法和查询有没有需要处理的softirqs如果有就启动对应类型的softirqs处理数据。等softirq结束之后结束整个中断运行流即调用iret。
    
##### Softirqs部分

> **软中断(softirqs)**和`int`指令触发的不同于硬件的软件中断(software interrupt)不同。

首先**softirqs**是一种延迟处理中断的方式。我先聊一下没有softirq的时候中断如何处理我拿网络中断举例子，网络中断会根据刚刚我提到的一系列的从硬件到**ISR**，拿到网络包数据，之后直接使用网络协议栈处理这个包处理完成之后，结束这个中断的执行流。紧接着再来一个网络中断又是一样拿到数据->使用协议栈处理包。如果同时出现10个网络中断这样就会不停的被中断打断进行上下文切换，10次中断就需要打断10次并且每一次都需要使用网络协议栈处理数据包。如果有一种方式可以让10次中断变成只从网卡DMA拿数据到操作系统的**FIFO**缓存中，最后一次一次性处理**FIFO**缓存里所有的数据包。这样就节省了调用网络协议栈的时候的时间了。

**softirqs**提供一个全局变量`pending`来记录不同类型的**softirqs**的[挂起]状态，一旦检测到有**softirqs**任务挂起，那么就会调用`do_softirq()`来处理具体的任务，一般`do_softirq()`会处理所有正在挂起的**softirq**。由于**softirq**是可以被打断的，所以**softirq**的任务要适合打断可以重入。本质上说pending这个bitmap是在标记各个**softirq**对应的处理数据源buffer有无数据的展示，另一个角度来看其实是一种`生产-消费`的模型，硬件中断**ISR**部分是被控制不能打断的“**生产者**”，而**softirqs**部分是可以被打断的 “**消费者**“。**生产者**通过`raise_softirqs()`来挂起某个类型(预约)一个**消费者**来处理他产生的数据。
    
    
> 名词解释
**挂起(pending)** 一个任务暂时无法执行，因为他需要的一些条件还没有被满足。我可能会翻译为"代办"

### 中断嵌套与中断优先级
中断嵌套存在两种不同定义的上下文。
1.中断嵌套的实现条件

    (1) 硬件支持
    PIC 或 APIC 必须支持中断优先级：
    如果中断 B 的优先级高于中断 A，PIC/APIC 会通知 CPU处理新的中断。
    低优先级的中断线（如 A）被屏蔽直到 B 处理完成。
    (2) 内核支持
    内核必须正确管理中断嵌套计数和上下文：
    进入新的中断时，内核会增加嵌套计数器。
    退出中断时，减少嵌套计数器，确保多层嵌套能够正确恢复。
    (3) 中断屏蔽机制
    通常，同一类型的中断（如同一个网卡的中断）会被内核配置为不可嵌套处理，以减少复杂性。
    但不同类型或更高优先级的中断可能会被允许打断。
    如果中断 B 到达而不能被响应，会发生什么？
    这取决于中断控制器和内核的配置。

如果中断到达而不能被响应会发生什么 

    (1) 中断被屏蔽（Masked）
    如果中断 B 被屏蔽（如同类型中断或低优先级中断），它将不会被响应。
    中断信号可能会保持挂起，直到屏蔽解除。例如：
    在 PIC 中，某条中断线被屏蔽时，即使有信号到达，PIC 不会通知 CPU。
    (2) 中断被丢弃
    某些硬件或驱动程序可能会忽略新的中断信号，而不会挂起等待。
    例如，在一些简单的设备中，如果缓冲区已满，新的中断可能被直接丢弃。
    (3) 中断队列（Interrupt Queuing）
    高级中断控制器（如 APIC 或现代 SoC 的中断控制器）可能会维护一个中断队列：
    当一个中断无法立即处理时，将其挂起。
    等待 CPU 处理完当前任务后再触发挂起的中断。
    (4) 中断 Storm 的风险
    如果新的中断持续到达而无法处理，可能导致所谓的 中断风暴（Interrupt Storm）。
    中断风暴会占用大量 CPU 时间，导致系统性能急剧下降

## 没有提到的内容
### 中断栈
    x64的设备会通过tss提供一个中断栈，Frog目前是32位系统所以等升级之后再考虑这些内容。

---

## 后

中断栈是64位引入的新内容，也许会再之后更新或者重新整理这篇文章。现在看来这篇文章
写的不太清楚。之后可能会更改一下行文。

Thu Feb 13 06:25:32 PM CST 2025
