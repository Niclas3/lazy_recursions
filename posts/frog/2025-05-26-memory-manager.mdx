---
layout: post
title: "🐸 Frog OS Memory: 再谈内存"
date: 2025-05-26
draft: false
categories: [frog, memory]
tags: []
---

## 释放指针也有门道
写C程序很常和地址、内存、指针打交道，自然会出现各种内存问题，导致程序结构混乱。写OS自然也会出现同样的问题，
这次我碰到的是一个初期定位在kmalloc函数（这是一个分配内核空间内存的函数）的Page fault, Frog OS使用的是一种类似buddy的内存管理策略
它把内存以需求大小分为了7种类型，把1KB切半再切半一直到16B。所以最小的分配block是16B。

这次的kmalloc就是在分配一个16B的内存时候发生了问题。Frog的mm模块使用的是分离式空闲列表，也就是维护一个空闲block的链表，如果对应的区块使用完了，就需要再申请一个area分割。
这次的bug，在申请16B内存的时候空闲列表的指针异常，像是对应的list_head的内存区域被破坏了。循着调用轨迹，定位到了一个函数释放了它不应该释放的某一个内存区域所导致的。

这件事情引发了我一些想法。首先，相同类型的错误是否可以避免？抽象一下问题， 问题就变成
1. 释放内存时候如何判断操作的内存指针是一个合法可以释放的指针？
2. 既然释放内存的时候会有问题那么操作内存block的时候是否也会越过block的界限导致内存溢出呢？

## 内存管理怎么办
我们带着这两个问题。先来看看内存为什么需要被管理？
在聊这个问题前，我们先单独看看内存这个概念。我们可以有很多角度来解释什么是内存，我今天只会从程序运行的角度来解释内存。如今我们所有的程序或者说代码，指令都是基于一种叫做
图灵机的理论发展来的，图灵机中有两个重要的一个叫做读写头，一个叫做无限长纸带。有了这两个东西所有的程序都可以被执行，其中纸带的实体化产物就是普遍意义上的存储空间，也就是今天我们要讨论的主体，内存。
内存是一种保存状态的机制，理论上只要可以保存状态都可以叫做内存，比如草稿纸。

了解完内存在程序意义上的概念。我们看为什么内存需要被管理？你一定发现了一件事情，我们在聊图灵机的时候提到了“无限”长的纸带，但是内存总是有限的，程序对于无限长纸带的需求和内存总是有限的事实，两者夹逼下催生出了内存管理。
【这里可以放一个三个砖头走路的gif】】
了解完为什么需要管理内存了，我们可以开始进入，怎么管理内存？

## 管理内存有什么核心任务
内存管理有什么工作呢？
1. 内存的分配和回收
2. 内存保护
3. 虚拟内存管理
4. 内存缓存

我们可以稍微回到刚开始Frog OS出现的bug，这个bug就是因为少了第二个内存保护功能所以出现了的问题。

## 内存的分配和回收
```
 * MEM_BITMAP_BASE at 0xc0060000
                     0x0006_0000
  +-----------------------+------------------+----------------+
  |      address          |   name           |     size       |
--+-----------------------+------------------+----------------+
|       0x0000_c508       |   GDT            |   100bytes     |
|       0x0000_c588       |   IDT            |   255 * 8bytes |
|       0x0006_0000       | MEM_BITMAP_BASE  |
|[0x0007_0000,0x0007cfcc] |   kernel code    |   20 pages     |
|       0x000a_0000       |   vga            |   x pages      |
|       0x000b_8000       |   text view      |   x pages      |
+--------------------------------------------+----------------+
|[0x0010_0000, PG_SZ *    |                  |                |
| (PDT_COUNT+PGT_COUNT)]  |                  |                |
|                         |   page table     |   3 pages      |
|                         |                  |                |
+-------------------------+------------------+----------------+
```
Frog内存管理还是比较阳春的。现在比较制式的内存管理方案首先是对页的管理，类似linux的buddy
system，然后是block的管理，也就是小内存的分配。目前frog的mm系统都是使用bitmap来管理的，后期再说
增加buddy-like的方案管理页。

对小内存的管理类似slob这种，frog使用了一个内存池的逻辑使用固定数据结构管理目前的空闲block, 目前每一个池子一个page size这么大，
按理说之后可能需要对池子本身也要有管理。目前还是可以用的，之后可能也需要添加对同一个类型的池子的扩容和缩容的代码。

## 内存保护
这一节我会结合Linux的KASAN技术来解释它是如何查觉内存访问越界。
| 类别                                       | 说明                      | 举例                                                       |
| ---------------------------------------- | ----------------------- | -------------------------------------------------------- |
| ✅ **越界访问（Out-of-bounds）**                | 读/写超出分配内存的边界            | `char *p = kmalloc(8); p[8] = 'x';`                      |
| ✅ **Use-after-free**                     | 使用已释放内存                 | `char *p = kmalloc(8); kfree(p); p[0] = 'x';`            |
| ✅ **Double free**                        | 同一个指针多次释放               | `kfree(p); kfree(p);`                                    |
| ✅ **未初始化访问（Uninitialized read）**         | 使用分配后未写入的内存             | `char *p = kmalloc(8); char x = p[0];`                   |
| ✅ **Use-after-return**                   | 返回的栈变量被继续使用             | `return &local_var;` 后继续使用                               |
| ✅ **Use-after-scope**                    | 局部变量作用域结束后被访问           | `{ char *p = &x; } *p = 1;`                              |
| ✅ **Invalid free**                       | 非 kmalloc 分配的指针传给 kfree | `char *p = (char *)0x12345678; kfree(p);`                |
| ✅ **Invalid write**                      | 向只读区或未映射内存写入            | `*((char *)0xdeadbeef) = 1;`                             |
| ✅ **内存泄漏**                               | 分配后没有释放                 | `kmalloc()` 没有对应 `kfree()`                               |
| ✅ **栈溢出（Stack overflow）**                | 超过内核栈大小或递归过深            | `void f() { char buf[8192]; f(); }`                      |
| ✅ **对 NULL 的解引用**                        | 未检查空指针就使用               | `struct task *t = NULL; t->pid = 1;`                     |
| ✅ **对 freed pointer 的偏移访问**              | 已释放区域 + 偏移访问，绕过简单检测     | `kfree(p); *(p + 2) = 1;`                                |
| ✅ **Heap corruption**                    | 写入越界破坏 allocator 的元数据   | `p[-1] = 1;` 改坏 block header                             |
| ✅ **Redzone 覆盖**                         | 写入 redzone（边界保护区）       | `kmalloc(8)`，写到第 9 字节                                    |
| ✅ **Memory aliasing / Tainted pointers** | 一个指针释放，另一个别名继续访问        | `char *a = kmalloc(8); char *b = a; kfree(a); b[0] = 1;` |

FrogOS会对如下进行保护
| 类别                | 原因                                 |
| ----------------- | ---------------------------------- |
| ✅ Use-after-free  | 调度器、驱动、fs 中非常常见，可能引起不可预测行为         |
| ✅ 越界写             | 很可能破坏内核数据结构，如 task struct、slab 元数据 |
| ✅ Double free     | 破坏 allocator，可能导致后续 kmalloc 返回野指针  |
| ✅ Stack overflow  | 内核栈本来就小（4K–8K），递归或大数组容易爆炸          |
| ✅ 无效访问（NULL, 未映射） | 内核 panic 直接触发，最容易发现但不容易复现原因        |

内存保护机制无非是在内存被使用的过程中防止程序没有按照规则使用被分配的资源。

内存的使用规则其实很简单
1. 有借有还
2. 不要使用自己没有借的内存，
3. 归还后的内存就不应该使用

我来依次看看这些是不是没有遵守规范。

use-after-free，违反了第三条
越界写        ，违反了第二条
double free   ，违反了第三条
stack overflow，违反了第二条
无效访问      ，违反了第二条
内存泄漏      ，违反了第一条

既然需要知道内存的额外信息，就需要额外的数据来支持，这时候就需要提出一个策略shadow
memory，影子内存，顾名思义，这个数据结构就像内存的影子一样提供一些额外信息来辅助内存管理。

影子内存技术，为每8 bytes的内存分配1 byte 的影子内存，通过影子内存的标记来记录这8bytes内存区域的访问权限
```
8 bytes memory                      | 1 byte shadow memory
+---+---+---+---+---+---+---+---+   | +---+---+
|   |   |   |   |   |   |   |   |   | | 0 | 0 |
+---+---+---+---+---+---+---+---+   | +---+---+
  0   1   2   3   4   5   6   7         0   1

+---+---+---+---+---+---+---+---+   | +---+---+
|   |   |   |   |   |###|###|###|   | | 0 | 5 |
+---+---+---+---+---+---+---+---+   | +---+---+
  0   1   2   3   4   5   6   7         0   1

+---+---+---+---+---+---+---+---+   | +---+---+
|###|###|###|###|###|###|###|###|   | | F | * |
+---+---+---+---+---+---+---+---+   | +---+---+
  0   1   2   3   4   5   6   7         0   1

```

如上面的演示，影子内存这个策略会在8
bytes内存对应的影子内存里通过数字来展示当前这8个bytes内存的可用情况，正数代表前几个byte可用。
负数就表示内存不可用，内存不可用的时候也有各自的Flag。
```
#define KASAN_FREE_PAGE 0xFF // page was freed
#define KASAN_PAGE_REDZONE 0xFE // redzone for kmalloc_large allocations
#define KASAN_KMALLOC_REDZONE 0xFC // redzone inside slub object
#define KASAN_KMALLOC_FREE    0xFB  // object was free(kmem_cache_free/kfree)
#define KASAN_GLOBAL_REDZONE  0xFA  // redzone for global variable
```

这时候我们又引入了红区的概念，redzone，就是在目标内存分配的时候在内存的边界的警戒线。这些地方不应该被访问。
（当然如果你已经知道一些内存布局，那你可以像詹姆斯邦德一样过红区，这是另一个需要讨论的领域我可能之后会写

你一下就可能发现，红区的大小设置是一个tread-off，太小了也许很容易被跳过，太大了会浪费内存。

| redzone 大小 | 特点                             | 推荐使用场景      |
| ---------- | ------------------------------ | ----------- |
| 8 字节       | 最小 redzone，不浪费太多内存             | 内存紧张、调试优先级低 |
| 16 字节      | 大多数内核分配器的默认值                   | 通用场景        |
| 32 字节      | 防止“越过 redzone 到下一个 block”的攻击技巧 | 更强防御但浪费较多   |
| 64 字节      | 一般过大，只有在做 fuzz 或 ASLR 硬化测试时使用  | 高安全、高开销场景   |

这时候可以通过 `#define KASAN_RADZONE_SIZE 16 `来规定一个默认值。
在slab分配器里，小的对象会获得32字节的红区因为小对象比较容易发生越界，而且越界发生就会跳过小红区
多一些可以做冗余防御。

红区的设定其实保证对齐8字节边界就好。因为我们的shadow memory是1：8的这样可以保证红区总是占有一个shadow memory的一个byte

红区就像一个保护网，它还需要一些配套的安保设备才能在越界发生的时候正确报警。当程序进行内存访问操作的时候无论是读数据还是
写数据，都需要在这之前添加一个shadow memory的检测步骤，因为shadow memory是1：8的比例，所以实际内存地址的右移3位就是shadow memory的
偏移量，再加上shadow memory的基地址就能获得对应的shadow memory byte。然后读取了shadow memory的值就能知道对应位置的内存访问是否合法了，不合法就进入错误流程

目前frog 的mm只有malloc/free有被下毒，之后可能会感染更多的内存操作函数。

## 虚拟内存管理

Frog当前的虚拟内存布局是什么样子
```
 Kernel virtual address space
                         +-------------------------------------+
0xC000_0000              |                                     |
                         |                                     |
                         |                                     |
                         |                                     |
0xC007_0000              +-------------------------------------+ kernel code
                         |                                     |
                         |                                     |
                         |                                     |
0xC007_CFCC              +-------------------------------------+ _end
                         |                                     |
(_end & ~0xfff) + 0x1000 +-------------------------------------+ kernel heap
bottom
                         |                                     |
                         |                                     |
                                     /* ... */
                         |                                     |
                         |                                     |
0xFF80_0000              +-------------------------------------+ kernel stack pool start
                         |                                     |
                         |                                     | reserver by kernel stack  / 1 pagesize 5page
0xFFBF_FFFF              +-------------------------------------+
0xFFC0_0000              +-------------------------------------+ Page table
Directory start
                         |                                     |
                         |                                     |
0xFFFF_FFFF              +-------------------------------------+
```

## 内存缓存
这里Frog还没有涉及，可以提出几个点看看能不能做

## 后
我这算是个小总结吧。

Sat May 31 08:43:49 PM CST 2025
